**1.开始,我们来看一个简单的程序, “loop.s”。首先,阅读这个程序,看看你是否能理**
**解它:`cat loop.s`。然后,用这些参数运行它:**
**`./x86.py -p loop.s -t 1 -i 100 -R dx`**
**这指定了一个单线程,每 100 条指令产生一个中断,并且追踪寄存器%dx。你能弄清楚**
**%dx 在运行过程中的价值吗?你有答案之后,运行上面的代码并使用-c 标志来检查你的答**
**案。注意答案的左边显示了右侧指令运行后寄存器的值(或内存的值)。**

不太懂汇编，“loop.s”大致的意思就是一个变量只要大于0就循环减1，有点像while(i--);

**答案**：

```
   dx          Thread 0         
    0   
   -1   1000 sub  $1,%dx
   -1   1001 test $0,%dx
   -1   1002 jgte .top
   -1   1003 halt
```



**2.现在运行相同的代码,但使用这些标志:**
**./x86.py -p loop.s -t 2 -i 100 -a dx=3,dx=3 -R dx**
**这指定了两个线程,并将每个%dx 寄存器初始化为 3。 %dx 会看到什么值?使用-c 标志**
**运行以查看答案。多个线程的存在是否会影响计算?这段代码有竞态条件吗?**

**答案**：

```
   dx          Thread 0                Thread 1         
    3   
    2   1000 sub  $1,%dx
    2   1001 test $0,%dx
    2   1002 jgte .top
    1   1000 sub  $1,%dx
    1   1001 test $0,%dx
    1   1002 jgte .top
    0   1000 sub  $1,%dx
    0   1001 test $0,%dx
    0   1002 jgte .top
   -1   1000 sub  $1,%dx
   -1   1001 test $0,%dx
   -1   1002 jgte .top
   -1   1003 halt
    3   ----- Halt;Switch -----  ----- Halt;Switch -----  
    2                            1000 sub  $1,%dx
    2                            1001 test $0,%dx
    2                            1002 jgte .top
    1                            1000 sub  $1,%dx
    1                            1001 test $0,%dx
    1                            1002 jgte .top
    0                            1000 sub  $1,%dx
    0                            1001 test $0,%dx
    0                            1002 jgte .top
   -1                            1000 sub  $1,%dx
   -1                            1001 test $0,%dx
   -1                            1002 jgte .top
   -1                            1003 halt

```

这段代码是没有竞态条件的，因为他们都没有试图更新共享的变量（或数据结构）



**3.现在运行以下命令:**
**./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx**
**这使得中断间隔非常小且随机。使用不同的种子和-s 来查看不同的交替。中断频率是否**
**会改变这个程序的行为?**

不会改变程序的行为, 两个线程都没有试图访问共享变量（或数据结构）



**4.接下来我们将研究一个不同的程序(looping-race-nolock.s)。**
**该程序访问位于内存地址 2000 的共享变量。简单起见,我们称这个变量为 x。使用单**
**线程运行它,并确保你了解它的功能,如下所示:**
**./x86.py -p looping-race-nolock.s -t 1 -M 2000**
**在整个运行过程中,x(即内存地址为 2000)的值是多少?使用-c 来检查你的答案。**

**答案**：

```
 2000          Thread 0         
    0   
    0   1000 mov 2000, %ax
    0   1001 add $1, %ax
    1   1002 mov %ax, 2000
    1   1003 sub  $1, %bx
    1   1004 test $0, %bx
    1   1005 jgt .top
    1   1006 halt
```



**5.现在运行多个迭代和线程:**
**./x86.py -p looping-race-nolock.s -t 2 -a bx=3 -M 2000**
**你明白为什么每个线程中的代码循环 3 次吗?x 的最终值是什么?**

嗯...，循环3次刚好退出循环，x的最终值是6



**6.现在以随机中断间隔运行:**
**./x86.py -p looping-race-nolock.s -t 2 -M 2000 -i 4 -r -s 0**
**然后改变随机种子,设置-s 1,然后-s 2 等。只看线程交替,你能说出 x 的最终值是什**
**么吗?中断的确切位置是否重要?在哪里发生是安全的?中断在哪里会引起麻烦?换句话**
**说,临界区究竟在哪里?**

-s 0：x最终值为2
-s 1：x最终值为1
-s 2：x最终值为2

中断的确切位置很重要，在临界区之外发生是安全的

**临界区代码**：

```assembly
mov 2000, %ax
add $1, %ax
mov %ax, 2000
```



**7.现在使用固定的中断间隔来进一步探索程序。**
**运行:**
**./x86.py -p looping-race-nolock.s -a bx=1 -t 2 -M 2000 -i 1**
**看看你能否猜测共享变量 x 的最终值是什么。当你改用-i 2, -i 3 等标志呢?对于哪个中**
**断间隔,程序会给出“正确的”最终答案?**

-i 1：x=1
-i 2：x=1
-i 3：x=2

-i 3是正确的



**8.现在为更多循环运行相同的代码(例如 set -a bx = 100)。使用-i 标志设置哪些中断**
**间隔会导致“正确”结果?哪些间隔会导致令人惊讶的结果?**

**正确结果举例**：

```sh
./x86.py -p looping-race-nolock.s -a bx=100 -t 2 -M 2000 -i 3 -c
./x86.py -p looping-race-nolock.s -a bx=100 -t 2 -M 2000 -i 6 -c
./x86.py -p looping-race-nolock.s -a bx=100 -t 2 -M 2000 -i 45 -c
./x86.py -p looping-race-nolock.s -a bx=100 -t 2 -M 2000 -i 201 -c
```

**令人惊讶的结果举例**：

```sh
./x86.py -p looping-race-nolock.s -a bx=100 -t 2 -M 2000 -i 1 -c
./x86.py -p looping-race-nolock.s -a bx=100 -t 2 -M 2000 -i 2 -c
./x86.py -p looping-race-nolock.s -a bx=100 -t 2 -M 2000 -i 59 -c
./x86.py -p looping-race-nolock.s -a bx=100 -t 2 -M 2000 -i 202 -c
```



**9.我们来看本作业中最后一个程序(wait-for-me.s)。**
**像这样运行代码:**
**./x86.py -p wait-for-me.s -a ax=1,ax=0 -R ax -M 2000**
**这将线程 0 的%ax 寄存器设置为 1,并将线程 1 的值设置为 0,在整个运行过程中观察**
**%ax 和内存位置 2000 的值。代码的行为应该如何?线程使用的 2000 位置的值如何?它的**
**最终值是什么?**

ax不是共享的所以无影响

2000位置的值是共享的，最终值为1



**10.现在改变输入:**
**./x86.py -p wait-for-me.s -a ax=0,ax=1 -R ax -M 2000**
**线程行为如何?线程 0 在做什么?改变中断间隔(例如,-i 1000,或者可能使用随机间**
**隔)会如何改变追踪结果?程序是否高效地使用了 CPU?**

线程 0 一直循环直到发生中断，线程 0 一直占用cpu，没有高效地使用 CPU
